<script src="https://cdnjs.cloudflare.com/ajax/libs/antv-g6/4.5.5/g6.min.js" integrity="sha512-AyQR/rps/XEPhyRHlLBss+9fho4OXKFH7G+Mb5wxPX7i4FMwBQjDMZyCcoqcXx0SpTviP1QGPVlpYErbs8/RWA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

<style>
.landing-graph-container {
    width: 100%;
    min-height: 600px;
    position: relative;
    left: 0%;
    overflow: visible;
}

.landing-graph {
    width: 100%;
    height: 100%;
    position:absolute;
    overflow: visible;
}
</style>

<div class="landing-graph-container">
    <div id="landing-graph" class="landing-graph"></div>
</div>

<script>
// Wrap everything to an anonymous function to avoid global names collision
((function() {

    // This function register a 'shape' node, which is not really a node, but 
    // a bezier curve attached to it (with some options to animate it)
    function registerShapeNode() {

        function drawBezierCurve(start, wide, height, middle, curve, center) {

            // Move command
            var startx = start.x;
            var starty = start.y;

            if (center) { startx = startx - wide / 2 }

            M = `M ${ startx} ${ starty }`

            // Curve command
            var topx = startx + wide * middle;
            var topy = starty - height;

            var endx = startx + wide;
            var endy = starty;

            var ldiff = topx - startx;
            var rdiff = startx + wide - topx;

            // Left anchor point
            var lanchorx = startx + ldiff * curve.left;
            var lanchory = starty;

            // Top anchor point
            var tanchorx = topx - ldiff * curve.top;
            var tanchory = topy;

            C = `C ${lanchorx} ${lanchory}, ${tanchorx} ${tanchory}, ${topx} ${topy}`

            // Right anchor point
            var ranchorx = endx - rdiff * curve.right;
            var ranchory = endy;

            S = `S ${ranchorx} ${ranchory}, ${endx} ${endy}`

            // Finish the shape to the end
            L = `L ${startx} ${starty}`

            // I've spend more than 3 hours on this function
            // https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths
            return `${M} ${C} ${S} ${L}`
        }

        function generateRandomProperties() {
            return { 
                base: { wide: 20, height: 20, middle: 0.5, curve: { left: 0.5, top: 0.25, right: 0.5, }},
                wide: Math.random() * 40,
                height: Math.random() * 40,
                middle: Math.random() * 0.4,
                curve: { 
                    left:  Math.random() * 0.75,
                    top:   Math.random() * 0.75,
                    right: Math.random() * 0.75,
                }
            }   
        }

        G6.registerNode('shape-node', {
            drawShape: (cfg, group) => {
                var color = cfg.color ? cfg.color : '#0aa8a7';     
                var props = generateRandomProperties()           

                var path = group.addShape('path', {
                    attrs: {
                        fill: color,
                        stroke: color,
                        cursor: 'pointer',
                        opacity: 0.0,
                        path: drawBezierCurve({ x: 0, y: 0 }, props.base.wide, props.base.height + props.height, props.base.middle, props.base.curve, true),
                    },
                    name: 'path-shape',
                });

                var animationDelay = 2000 + Math.random() * 1000;

                // In the beginning shapes are not visible
                path.animate((ratio) => ({ opacity: 0.4 * ratio }), { repeat: false, duration: animationDelay, easing: 'easeCubic' })

                path.animate((ratio) => {
                    var bratio = Math.sin(ratio * Math.PI)
                    var wide   = props.base.wide + props.wide * bratio;
                    var height = props.base.height + props.height * (1 - bratio);
                    var middle = props.base.middle + props.middle * (1/2 - bratio);
                    return {
                        path: drawBezierCurve({ x: 0, y: 0 }, wide, height, middle, props.base.curve, true),
                    }
                }, { repeat: true, duration: 2000 + Math.random() * 1000, delay: Math.random() * 1000, easing: 'easeCubic' })

                return path
            },
            setState(name, value, item) {
                var shape = item.get('keyShape');
                if (name === 'hover') {
                    shape.animate((ratio) => ({ 
                        opacity: 0.5 + 0.5 * (value ? ratio : (1 - ratio)) 
                    }), { repeat: false, duration: 300, easing: 'easeCubic' });
                }
            },
        }, 'rect');
    }

    // This function register a simple fully transparent node, 
    // that can be used to put labels or add dangling edges
    function registerInvisibleNode() {
        var invisibleNodeDefaultSize = 25;
        G6.registerNode('invisible-node', {
            options: { labelCfg: { style: { fill: '#0aa8a7' } } },
            drawShape: (cfg, group) => {
                var size  = (cfg.size !== undefined) ? cfg.size : invisibleNodeDefaultSize;
                return group.addShape('rect', {
                    attrs: {
                        x:       -size / 2,
                        y:       -size / 2,
                        width:   size,
                        height:  size,
                        fill:    'white',
                        stroke:  'white',
                        opacity: 0.0,
                    },
                    name: 'inode-box'
                });
            },
            getAnchorPoints(cfg) {
                return [ [ 0.5, 0.5 ], [ 0.0, 0.5 ], [ 0.5, 1.0 ], [ 1.0, 0.5 ], [ 0.5, 0.0 ] ]
            },
        }, 'rect');
    }

    function registerFactorNode() {
        var fillColor   = '#f5f7f7';
        var strokeColor = '#0aa8a7';
        var gsize = 50;

        G6.registerNode(
            'factor-node',
            {
                options: {
                    labelCfg: { style: { opacity: 0.0, }, } // disable default label
                },
                drawShape: (cfg, group) => {
                    var size        = (cfg.size !== undefined) ? cfg.size : gsize;
                    var shape       = group.addShape('rect', {
                        attrs:     {
                            x:             -size / 2,
                            y:             -size / 2,
                            width:         size,
                            height:        size,
                            fill:          fillColor,
                            stroke:        strokeColor,
                            radius:        2,
                            cursor:        'pointer',
                            opacity:       1.0,
                            shadowColor:   '#c2c2c2',
                        },
                        
                        name:      'gnode-box',
                        draggable: true
                    });

                    group.addShape('text', {
                        attrs: {
                            y:            0,
                            x:            0,
                            textAlign:    'center',
                            textBaseline: 'middle',
                            lineHeight:   10,
                            text:         cfg.label,
                            fill:         strokeColor,
                            fontSize:     size / 2.5,
                            fontWeight:   'bold'
                        },
                        name:  'gnode-type-text'
                    });

                    return shape
                },
                // Override setState
                setState(name, value, item) {
                    var shape = item.get('keyShape');
                    var size  = (shape.cfg.attrs.width !== undefined) ? shape.cfg.attrs.width : gsize;
                    var shadowOffset = 10;
                    var shadowBlur = 50;
                    // Response the running state
                    if (name === 'hover') {
                        // When the running state is turned to be true
                        if (value) {
                            shape.stopAnimate();
                            shape.animate((ratio) => { 
                                var newsize =  size + (size / 10) * ratio;
                                return { 
                                    height: newsize, 
                                    width: newsize,
                                    x: -newsize / 2,
                                    y: -newsize / 2,
                                    shadowOffsetX: shadowOffset * ratio,
                                    shadowOffsetY: shadowOffset * ratio,
                                    shadowBlur:    shadowBlur * ratio,
                                }
                            }, { repeat: false, duration: 300, easing: 'easeCubic' });
                        } else {
                            shape.stopAnimate();
                            shape.animate((ratio) => { 
                                var newsize =  size + (size / 10) * (1 - ratio);
                                return { 
                                    height: newsize, 
                                    width: newsize,
                                    x: -newsize / 2,
                                    y: -newsize / 2,
                                    shadowOffsetX: shadowOffset * (1 - ratio),
                                    shadowOffsetY: shadowOffset * (1 - ratio),
                                    shadowBlur:    shadowBlur * (1 - ratio),
                                }
                            }, { repeat: false, duration: 300, easing: 'easeCubic' });
                        }
                    }
                },
                getAnchorPoints(cfg) {
                    return [
                        [ 0.5, 0.5 ],
                        [ 0.0, 0.5 ],
                        [ 0.5, 1.0 ],
                        [ 1.0, 0.5 ],
                        [ 0.5, 0.0 ]
                    ]
                },
            },
            
            'rect',
        );
    }

    function registerEqualityNode() {
        var fillColor   = '#ffffff';
        var size        = 20;
        var strokeColor = '#bababa';
        var labelStrokeColor = '#bababa';
        G6.registerNode(
            'equality-node',
            {
                drawShape: (cfg, group) => {
                    
                    var shape       = group.addShape('rect', {
                        attrs:     {
                            x:             -size / 2,
                            y:             -size / 2,
                            width:         size,
                            height:        size,
                            fill:          fillColor,
                            stroke:        strokeColor,
                            radius:        3,
                            cursor:        'pointer',
                            opacity:       1.0
                        },
                        name:      'gnode-box',
                        draggable: true
                    });

                    group.addShape('text', {
                        attrs: {
                            y:            0,
                            x:            0,
                            textAlign:    'center',
                            textBaseline: 'middle',
                            lineHeight:   10,
                            text:         "=",
                            fill:         labelStrokeColor,
                            fontSize:     size / 2.5,
                            fontWeight:   'bold'
                        },
                        name:  'gnode-type-text'
                    });

                    return shape
                },
                // Override setState
                setState(name, value, item) {
                    var shape = item.get('keyShape');
                    // Response the running state
                    if (name === 'hover') {
                        // When the running state is turned to be true
                        if (value) {
                            shape.stopAnimate();
                            shape.animate((ratio) => { 
                                var newsize =  size + (size / 10) * ratio;
                                return { 
                                    height: newsize, 
                                    width: newsize,
                                    x: -newsize / 2,
                                    y: -newsize / 2,
                                }
                            }, { repeat: false, duration: 300, easing: 'easeCubic' });
                        } else {
                            shape.stopAnimate();
                            shape.animate((ratio) => { 
                                var newsize =  size + (size / 10) * (1 - ratio);
                                return { 
                                    height: newsize, 
                                    width: newsize,
                                    x: -newsize / 2,
                                    y: -newsize / 2,
                                }
                            }, { repeat: false, duration: 300, easing: 'easeCubic' });
                        }
                    }
                },
                getAnchorPoints(cfg) {
                    return [
                        [ 0.5, 0.5 ],
                        [ 0.0, 0.5 ],
                        [ 0.5, 1.0 ],
                        [ 1.0, 0.5 ],
                        [ 0.5, 0.0 ]
                    ]
                },
            },
            'rect',
        );
    }

    function registerFactorEdge() {
        var animationCircleFillColor   = '#edf6f5';
        var animationCircleStrokeColor = '#0aa8a7';
        G6.registerEdge(
            'factor-edge',
            {
                afterDraw(cfg, group) {
                    // Get the first graphics shape of this type of edge, which is the edge's path
                    var shape = group.get('children')[0];
                    // The start point of the edge's path
                    var startPoint = shape.getPoint(0);

                    // Add a red circle shape
                    var circle = group.addShape('circle', {
                        attrs: {
                            x: startPoint.x,
                            y: startPoint.y,
                            fill: animationCircleFillColor,
                            stroke: animationCircleStrokeColor,
                            r: 3,
                        },
                        // must be assigned in G6 3.3 and later versions. it can be any value you want
                        name: 'circle-shape',
                    });

                    // Add the animation to the red circle
                    circle.animate(
                        (ratio) => {
                            // Returns the properties for each frame. The input parameter ratio is a number that range from 0 to 1. The return value is an object that defines the properties for this frame
                            // Get the position on the edge according to the ratio
                            var tmpPoint = shape.getPoint(ratio);
                            // Return the properties of this frame, x and y for this demo
                            return {
                                x: tmpPoint.x,
                                y: tmpPoint.y,
                                opacity: Math.sin(ratio * Math.PI),
                                r: Math.sin(ratio * Math.PI) * 3
                            };
                        },
                        {
                            repeat: true, // Play the animation repeatly
                            duration: (500 + 1000 * Math.random()), // The duration for one animation
                        },
                    );
                },
            },
            'line',
        ); // Extend the built-in edge cubic
    }
    
    // Register custom nodes
    registerInvisibleNode();
    registerShapeNode();
    registerFactorNode();
    registerEqualityNode();
    registerFactorEdge();

    var data = {
        nodes: [
            // Top shape nodes
            { id: 'shape10', x: -110, y: 70, type: 'shape-node', color: '#17a2b8' },
            { id: 'shape11', x: -100, y: 70, type: 'invisible-node', label: 'x_t' },
            { id: 'shape12', x: -90, y: 70, type: 'shape-node', color: '#fd7e14' },

            { id: 'shape20', x: 90, y: 70, type: 'shape-node', color: '#dc3545'  },
            { id: 'shape21', x: 100, y: 70, type: 'invisible-node', label: 'x_t' },
            { id: 'shape22', x: 110, y: 70, type: 'shape-node', color: '#17a2b8' },

            { id: 'shape30', x: 290, y: 70, type: 'shape-node', color: '#6f42c1' },
            { id: 'shape31', x: 300, y: 70, type: 'invisible-node', label: 'x_t' },
            { id: 'shape32', x: 310, y: 70, type: 'shape-node', color: '#007bff' },

            { id: 'shape40', x: 490, y: 70, type: 'shape-node', color: '#28a745' },
            { id: 'shape41', x: 500, y: 70, type: 'invisible-node', label: 'x_t' },
            { id: 'shape42', x: 510, y: 70, type: 'shape-node', color: '#dc3545' },

            // Bottom shape nodes
            { id: 'shape50', x: -150, y: 400, type: 'shape-node', color: '#17a2b8' },
            // { id: 'shape51', x: -100, y: 370, type: 'invisible-node', label: 'x_t' },

            // Top layer
            { id: 'z-e00', x: -1000, y: 100, type: 'invisible-node' },
            { id: 'z-e01', x: 1400, y: 100, type: 'invisible-node' },

            { id: 'z-g0', x: -200, y: 100, type: 'factor-node', label: 'N' },
            { id: 'z-g0-i', x: -200, y: 0, type: 'invisible-node' },

            { id: 'z-g1', x: 0, y: 100, type: 'factor-node', label: 'N' },
            { id: 'z-g1-i', x: 0, y: 0, type: 'invisible-node' },

            { id: 'z-g2', x: 200, y: 100, type: 'factor-node', label: 'N' },
            { id: 'z-g2-i', x: 200, y: 0, type: 'invisible-node' },

            { id: 'z-g3', x: 400, y: 100, type: 'factor-node', label: 'N' },
            { id: 'z-g3-i', x: 400, y: 0, type: 'invisible-node' },

            { id: 'z-g4', x: 600, y: 100, type: 'factor-node', label: 'N' },
            { id: 'z-g4-i', x: 600, y: 0, type: 'invisible-node' },

            { id: 'z-e0', x: -100, y: 100, type: 'equality-node' },
            { id: 'z-e1', x: 100, y: 100, type: 'equality-node' },
            { id: 'z-e2', x: 300, y: 100, type: 'equality-node' },
            { id: 'z-e3', x: 500, y: 100, type: 'equality-node' },

            // Multiplication layer
            { id: 'm-e00', x: -1000, y: 160, type: 'invisible-node' },
            { id: 'm-e01', x: 1400, y: 160, type: 'invisible-node' },

            { id: 'm-e0', x: -200, y: 160, type: 'equality-node' },
            { id: 'm-e1', x: 0, y: 160, type: 'equality-node' },
            { id: 'm-e2', x: 200, y: 160, type: 'equality-node' },
            { id: 'm-e3', x: 400, y: 160, type: 'equality-node' },
            { id: 'm-e4', x: 600, y: 160, type: 'equality-node' },

            { id: 'm-g00', x: -1000, y: 290, type: 'invisible-node' },
            { id: 'm-g01', x: 1400, y: 290, type: 'invisible-node' },
            { id: 'm-g0', x: -200, y: 290, type: 'factor-node', label: '✕', size: 30 },
            { id: 'm-g1', x: 0,    y: 290, type: 'factor-node'   , label: '✕', size: 30 },
            { id: 'm-g2', x: 200,  y: 290, type: 'factor-node' , label: '✕', size: 30 },
            { id: 'm-g3', x: 400,  y: 290, type: 'factor-node' , label: '✕', size: 30 },
            { id: 'm-g4', x: 600,  y: 290, type: 'factor-node' , label: '✕', size: 30 },

            // Middle layer 
            { id: 'x-g0', x: -100, y: 225, type: 'factor-node', label: 'f', size: 30 },
            { id: 'x-g1', x: 100, y: 225, type: 'factor-node', label: 'f' , size: 30 },
            { id: 'x-g2', x: 300, y: 225, type: 'factor-node', label: 'f' , size: 30 },
            { id: 'x-g3', x: 500, y: 225, type: 'factor-node', label: 'f' , size: 30 },

            { id: 's-g0', x: -100, y: 290, type: 'factor-node', label: 'N' },
            { id: 's-g1', x: 100, y: 290, type: 'factor-node', label: 'N' },
            { id: 's-g2', x: 300, y: 290, type: 'factor-node', label: 'N' },
            { id: 's-g3', x: 500, y: 290, type: 'factor-node', label: 'N' },

            // Bottom layer
            { id: 'b-i0', x: -100, y: 390, type: 'invisible-node' },
            { id: 'b-i1', x: 100, y: 390, type: 'invisible-node' },
            { id: 'b-i2', x: 300, y: 390, type: 'invisible-node' },
            { id: 'b-i3', x: 500, y: 390, type: 'invisible-node' },
            

        ],
        edges: [
            

            // Top layer
            { source: 'z-e00', target: 'z-g0', type: 'factor-edge' },
            { source: 'z-g4', target: 'z-e01', type: 'factor-edge' },
            { source: 'z-g0-i', target: 'z-g0', type: 'factor-edge' },
            { source: 'z-g0', target: 'z-e0', type: 'factor-edge' },
            { source: 'z-e0', target: 'z-g1', type: 'factor-edge' },
            { source: 'z-g1-i', target: 'z-g1', type: 'factor-edge' },
            { source: 'z-g1', target: 'z-e1', type: 'factor-edge' },
            { source: 'z-e1', target: 'z-g2', type: 'factor-edge' },
            { source: 'z-g2-i', target: 'z-g2', type: 'factor-edge' },
            { source: 'z-g2', target: 'z-e2', type: 'factor-edge' },
            { source: 'z-e2', target: 'z-g3', type: 'factor-edge' },
            { source: 'z-g3-i', target: 'z-g3', type: 'factor-edge' },
            { source: 'z-g3', target: 'z-e3', type: 'factor-edge' },
            { source: 'z-e3', target: 'z-g4', type: 'factor-edge' },
            { source: 'z-g4-i', target: 'z-g4', type: 'factor-edge' },

            // Multiplication layer
            { source: 'm-e00', target: 'm-e0', type: 'factor-edge' },
            { source: 'm-e4', target: 'm-e01', type: 'factor-edge' },
            { source: 'm-e0', target: 'm-e1', type: 'factor-edge' },
            { source: 'm-e1', target: 'm-e2', type: 'factor-edge' },
            { source: 'm-e2', target: 'm-e3', type: 'factor-edge' },
            { source: 'm-e3', target: 'm-e4', type: 'factor-edge' },
            { source: 'm-e0', target: 'm-g0', type: 'factor-edge' },
            { source: 'm-e1', target: 'm-g1', type: 'factor-edge' },
            { source: 'm-e2', target: 'm-g2', type: 'factor-edge' },
            { source: 'm-e3', target: 'm-g3', type: 'factor-edge' },
            { source: 'm-e4', target: 'm-g4', type: 'factor-edge' },
            { source: 'm-g00', target: 'm-g0', type: 'factor-edge' },
            { source: 'm-g4', target: 'm-g01', type: 'factor-edge' },

            { source: 'm-g0', target: 's-g0', type: 'factor-edge' },
            { source: 's-g0', target: 'm-g1', type: 'factor-edge' },

            { source: 'm-g1', target: 's-g1', type: 'factor-edge' },
            { source: 's-g1', target: 'm-g2', type: 'factor-edge' },

            { source: 'm-g2', target: 's-g2', type: 'factor-edge' },
            { source: 's-g2', target: 'm-g3', type: 'factor-edge' },

            { source: 'm-g3', target: 's-g3', type: 'factor-edge' },
            { source: 's-g3', target: 'm-g4', type: 'factor-edge' },


            // Middle layer
            { source: 'z-e0', target: 'x-g0', type: 'factor-edge' },
            { source: 'z-e1', target: 'x-g1', type: 'factor-edge' },
            { source: 'z-e2', target: 'x-g2', type: 'factor-edge' },
            { source: 'z-e3', target: 'x-g3', type: 'factor-edge' },

            { source: 'x-g0', target: 's-g0', type: 'factor-edge' },
            { source: 'x-g1', target: 's-g1', type: 'factor-edge' },
            { source: 'x-g2', target: 's-g2', type: 'factor-edge' },
            { source: 'x-g3', target: 's-g3', type: 'factor-edge' },
            
            // Bottom layer
            { source: 's-g0', target: 'b-i0', type: 'factor-edge' },
            { source: 's-g1', target: 'b-i1', type: 'factor-edge' },
            { source: 's-g2', target: 'b-i2', type: 'factor-edge' },
            { source: 's-g3', target: 'b-i3', type: 'factor-edge' },
        ],
    };

    var graph = new G6.Graph({ 
        container: 'landing-graph', 
        fitCenter: true,
        animate: true,
        // modes: {
        //     default: ['drag-node'],
        // },
    });

    window.addEventListener('resize', () => {
        graph.changeSize(window.innerWidth, 400)
        graph.fitCenter();
        graph.zoom(1.25, { x: window.innerWidth / 2, y: 300 }, true, {
            duration: 2000, easing: 'easeCubic'
        });
    })

    graph.on('node:mouseenter', (e) => graph.setItemState(e.item, 'hover', true));
    graph.on('node:mouseleave', (e) => graph.setItemState(e.item, 'hover', false));

    graph.data(data);
    graph.render();

    window.setTimeout(() => {
        graph.zoom(1.5, { x: window.innerWidth / 2, y: 300 }, true, {
            duration: 2000, easing: 'easeCubic'
        });
    }, 100)
})())

</script>